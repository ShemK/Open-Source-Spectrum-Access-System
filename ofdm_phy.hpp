/*
//  This is an adaptation of the CRTS Code from https://github.com/ericps1/crts/
//
//
//
//
*/
#include <liquid/liquid.h>
#include <pthread.h>
#include <iostream>
#include <fstream>
#include <net/if.h>
#include <uhd/utils/msg.hpp>
#include <uhd/usrp/multi_usrp.hpp>
#include <uhd/types/tune_request.hpp>
#include <fcntl.h>
#include "timer.h"
#include "MAC.hpp"
#include "loop.hpp"
#include <sys/time.h>
#include "BufferQ.h"
#include <fftw3.h>

#define RED "\x1B[31m"
#define GRN "\x1B[32m"
#define YEL "\x1B[33m"
#define BLU "\x1B[34m"
#define MAG "\x1B[35m"
#define CYN "\x1B[36m"
#define WHT "\x1B[37m"
#define RESET "\x1B[0m"


#define PHY_CONTROL_INFO_BYTES 6

// thread functions
void *PHY_tx_worker(void *_arg);
void *PHY_rx_worker(void *_arg);
void *PHY_ce_worker(void *_arg);
void *analysis(void *_arg);


// function that receives frame from PHY layer
int rxCallback(unsigned char *_header, int _header_valid,
               unsigned char *_payload, unsigned int _payload_len,
               int _payload_valid, framesyncstats_s _stats, void *_userdata);

/// \brief Defines the possible states of the transmitter, which
/// can be either off, continuously transmittering, or transmitting
/// for a finite number of frames.
enum tx_states
{
  TX_STOPPED = 0,
  TX_CONTINUOUS,
  TX_BURST
};

/// \brief Defines the possible states of the receiver, which
/// can be either off, or continuously receiving.
enum rx_states
{
  RX_STOPPED = 0,
  RX_CONTINUOUS
};

/// \brief Defines states for worker threads, which can be
/// halted, ready, or running.
enum worker_states
{
  WORKER_HALTED = 0,
  WORKER_READY,
  WORKER_RUNNING
};

class PhyLayer
{
public:
  PhyLayer();
  ~PhyLayer();

  mqd_t phy_tx_queue;
  mqd_t phy_rx_queue;
  //=================================================================================
  // Enums and Structs
  //=================================================================================

  /// \brief Defines the types of frames used by the PHY
  enum FrameType
  {

    /// \brief The frame contains application
    /// layer data.
    ///
    /// Data frames contain IP packets that are read from
    /// the virtual network interface and subsequently
    /// transmitted over the air.
    DATA = 0,

    /// \brief The frame was sent explicitly at the
    /// behest of another cognitive engine (CE) in the
    /// network and it contains custom data for use
    /// by the receiving CE.
    ///
    /// The handling of PhyLayer::DATA
    /// frames is performed automatically by the
    /// Extensible Cognitive Radio (PHY).
    /// However, the CE may initiate the transmission
    /// of a custom control frame containing
    /// information to be relayed to another CE in the
    /// network.
    /// A custom frame can be sent using
    /// PhyLayer::transmit_frame().
    CONTROL,

    /// \brief The Extensible Cognitve Radio (PHY) is
    /// unable to determine the type of the received frame.
    ///
    /// The received frame was too corrupted to determine
    /// its type.
    UNKNOWN
  };

  /// \brief Contains parameters defining how
  /// to handle frame transmission.
  ///
  /// The member parameters are accessed using the
  /// instance of the struct:
  /// PhyLayer::tx_params.
  ///
  /// Note that for frames to be received successfully
  /// These settings must match the corresponding settings
  /// at the receiver.
  struct tx_parameter_s
  {

    /// \brief The number of subcarriers in the OFDM waveform
    /// generated by
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for details.
    unsigned int numSubcarriers; // number of subcarriers

    /// \brief The length of the cyclic prefix in the OFDM waveform
    /// generator from
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for details.
    unsigned int cp_len; // cyclic prefix length

    /// \brief The overlapping taper length in the OFDM waveform
    /// generator from
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// and the
    /// <a
    /// href="http://liquidsdr.org/doc/framing.html#framing:ofdmflexframe:tapering">Liquid
    /// Documentation Reference</a>
    /// for details.
    unsigned int taper_len; // taper length

    /// \brief An array of \p unsigned \p char whose number of elements is
    /// PhyLayer::tx_parameter_s::numSubcarriers.
    /// Each element in the array should define that subcarrier's allocation.
    ///
    /// A subcarrier's allocation defines it as a null subcarrier, a pilot
    /// subcarrier, or a data subcarrier.
    ///
    /// See
    /// <a
    /// href="http://liquidsdr.org/doc/framing.html#framing:ofdmflexframe:subcarrier_allocation">Subcarrier
    /// Allocation</a>
    /// in the
    /// <a href="http://liquidsdr.org/">liquid</a>
    /// documentation for details.
    ///
    /// Also refer to the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for more information.
    unsigned char *subcarrierAlloc;

    /// \brief The properties for the OFDM frame generator from
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">Liquid
    /// Documentation</a>
    /// for details.
    ///
    /// Members of this struct can be accessed with the following functions:
    /// - \p check:
    ///     + PhyLayer::set_tx_crc()
    ///     + PhyLayer::get_tx_crc().
    /// - \p fec0:
    ///     + PhyLayer::set_tx_fec0()
    ///     + PhyLayer::get_tx_fec0().
    /// - \p fec1:
    ///     + PhyLayer::set_tx_fec1()
    ///     + PhyLayer::get_tx_fec1().
    /// - \p mod_scheme:
    ///     + PhyLayer::set_tx_modulation()
    ///     + PhyLayer::get_tx_modulation().
    ofdmflexframegenprops_s fgprops; // frame generator properties

    /// \brief The value of the hardware gain for the transmitter. In dB.
    ///
    /// Sets the gain of the hardware amplifier in the transmit chain
    /// of the USRP.
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    ///
    /// It can be accessed with PhyLayer::set_tx_gain_uhd()
    /// and PhyLayer::get_tx_gain_uhd().
    ///
    /// Run
    ///
    ///     $ uhd_usrp_probe
    ///
    /// for details about the particular gain limits of your USRP device.
    double tx_gain_uhd;

    /// \brief The software gain of the transmitter. In dB.
    ///
    /// In addition to the hardware gain
    /// (PhyLayer::tx_parameter_s::tx_gain_uhd),
    /// the gain of the transmission can be adjusted in software by
    /// setting this parameter.  It is converted to a linear factor
    /// and then applied to the frame samples before they are sent to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    ///
    /// It can be accessed with PhyLayer::set_tx_gain_soft()
    /// and PhyLayer::get_tx_gain_soft().
    ///
    /// Note that the values of samples sent to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>
    /// must be between -1 and 1.
    /// Typically this value is set to around -12 dB based on the peak-
    /// to-average power ratio of OFDM signals. Allowing some slight
    /// clipping can improve overall signal power at the expense of
    /// added distortion.
    double tx_gain_soft;

    /// \brief The transmitter local oscillator frequency in Hertz.
    ///
    /// It can be accessed with PhyLayer::set_tx_freq()
    /// and PhyLayer::get_tx_freq().
    ///
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    double tx_freq;

    /// \brief The transmitter NCO frequency in Hertz.
    ///
    /// The USRP has an NCO which can be used to digitally mix
    /// the signal anywhere within the baseband bandwidth of the
    /// USRP daughterboard. This can be useful for offsetting the
    /// tone resulting from LO leakage of the ZIF transmitter
    /// used by the USRP.
    double tx_dsp_freq;

    /// \brief The sample rate of the transmitter in samples/second.
    ///
    /// It can be accessed with PhyLayer::set_tx_rate()
    /// and PhyLayer::get_tx_rate().
    ///
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    double tx_rate;

    unsigned int payload_sym_length;
  };

  // rx parameter struct
  /// \brief Contains parameters defining how
  /// to handle frame reception.
  ///
  /// The member parameters are accessed using the
  /// instance of the struct:
  /// PhyLayer::tx_params.
  ///
  /// Note that for frames to be received successfully
  /// These settings must match the corresponding settings
  /// at the transmitter.
  struct rx_parameter_s
  {

    /// \brief The number of subcarriers in the OFDM waveform
    /// generated by
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for details.
    unsigned int numSubcarriers; // number of subcarriers

    /// \brief The length of the cyclic prefix in the OFDM waveform
    /// generator from
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for details.
    unsigned int cp_len; // cyclic prefix length

    /// \brief The overlapping taper length in the OFDM waveform
    /// generator from
    /// <a href="http://liquidsdr.org/">liquid</a>.
    ///
    /// See the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// and the
    /// <a
    /// href="http://liquidsdr.org/doc/framing.html#framing:ofdmflexframe:tapering">Liquid
    /// Documentation Reference</a>
    /// for details.
    unsigned int taper_len; // taper length

    /// \brief An array of \p unsigned \p char whose number of elements is
    /// PhyLayer::tx_parameter_s::numSubcarriers.
    /// Each element in the array should define that subcarrier's allocation.
    ///
    /// A subcarrier's allocation defines it as a null subcarrier, a pilot
    /// subcarrier, or a data subcarrier.
    ///
    /// See
    /// <a
    /// href="http://liquidsdr.org/doc/framing.html#framing:ofdmflexframe:subcarrier_allocation">Subcarrier
    /// Allocation</a>
    /// in the
    /// <a href="http://liquidsdr.org/">liquid</a>
    /// documentation for details.
    ///
    /// Also refer to the
    /// <a href="http://liquidsdr.org/doc/tutorial_ofdmflexframe.html">OFDM
    /// Framing Tutorial</a>
    /// for more information.
    unsigned char *subcarrierAlloc;

    /// \brief The value of the hardware gain for the receiver. In dB.
    ///
    /// Sets the gain of the hardware amplifier in the receive chain
    /// of the USRP.
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    ///
    /// It can be accessed with PhyLayer::set_rx_gain_uhd()
    /// and PhyLayer::get_rx_gain_uhd().
    ///
    /// Run
    ///
    ///     $ uhd_usrp_probe
    ///
    /// for details about the particular gain limits of your USRP device.
    double rx_gain_uhd;

    /// \brief The receiver local oscillator frequency in Hertz.
    ///
    /// It can be accessed with PhyLayer::set_rx_freq()
    /// and PhyLayer::get_rx_freq().
    ///
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    double rx_freq;

    /// \brief The transmitter NCO frequency in Hertz.
    ///
    /// The USRP has an NCO which can be used to digitally mix
    /// the signal anywhere within the baseband bandwidth of the
    /// USRP daughterboard. This can be useful for offsetting the
    /// tone resulting from LO leakage of the ZIF receiver
    /// used by the USRP.
    double rx_dsp_freq;

    /// \brief The sample rate of the receiver in samples/second.
    ///
    /// It can be accessed with PhyLayer::set_rx_rate()
    /// and PhyLayer::get_rx_rate().
    ///
    /// This value is passed directly to
    /// <a href="http://files.ettus.com/manual/index.html">UHD</a>.
    double rx_rate;
  };

  //=================================================================================
  // Transmitter Methods
  //=================================================================================

  /// \brief Set the value of PhyLayer::tx_parameter_s::tx_freq.
  void set_tx_freq(double _tx_freq);

  void set_tx_freq(double _tx_freq, double _dsp_freq);

  /// \brief Set the value of PhyLayer::tx_parameter_s::tx_rate.
  void set_tx_rate(double _tx_rate);

  /// \brief Set the value of
  /// PhyLayer::tx_parameter_s::tx_gain_soft.
  void set_tx_gain_soft(double _tx_gain_soft);

  /// \brief Set the value of
  /// PhyLayer::tx_parameter_s::tx_gain_uhd.
  void set_tx_gain_uhd(double _tx_gain_uhd);

  void set_tx_antenna(char *_tx_antenna);

  /// \brief Set the value of \p mod_scheme in
  /// PhyLayer::tx_parameter_s::fgprops.
  void set_tx_modulation(int mod_scheme);

  /// \brief Set the value of \p check in
  /// PhyLayer::tx_parameter_s::fgprops.
  void set_tx_crc(int crc_scheme);

  /// \brief Set the value of \p fec0 in
  /// PhyLayer::tx_parameter_s::fgprops.
  void set_tx_fec0(int fec_scheme);

  /// \brief Set the value of \p fec1 in
  /// PhyLayer::tx_parameter_s::fgprops.
  void set_tx_fec1(int fec_scheme);

  /// \brief Set the value of
  /// PhyLayer::tx_parameter_s::numSubcarriers.
  void set_tx_subcarriers(unsigned int subcarriers);

  /// \brief Set PhyLayer::tx_parameter_s::subcarrierAlloc.
  void set_tx_subcarrier_alloc(char *_subcarrierAlloc);

  /// \brief Set the value of PhyLayer::tx_parameter_s::cp_len.
  void set_tx_cp_len(unsigned int cp_len);

  /// \brief Set the value of
  /// PhyLayer::tx_parameter_s::taper_len.
  void set_tx_taper_len(unsigned int taper_len);

  /// \brief Set the control information used for future transmit frames.
  void set_tx_control_info(unsigned char *_control_info);

  /// \brief Set the number of symbols transmitted in each frame payload.
  /// For now since the PHY does not have any segmentation/concatenation
  /// capabilities,
  /// the actual payload will be an integer number of IP packets, so this value
  /// really
  /// provides a lower bound for the payload length in symbols.
  void set_tx_payload_sym_len(unsigned int len);

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_freq.
  double get_tx_freq();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_freq.
  double get_tx_lo_freq();

  /// \brief Return the value of
  /// PhyLayer::tx_state.
  int get_tx_state();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_freq.
  double get_tx_dsp_freq();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_rate.
  double get_tx_rate();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_gain_soft.
  double get_tx_gain_soft();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::tx_gain_uhd.
  double get_tx_gain_uhd();

  char *get_tx_antenna();

  /// \brief Return the value of \p mod_scheme in
  /// PhyLayer::tx_parameter_s::fgprops.
  int get_tx_modulation();

  /// \brief Return the value of \p check in
  /// PhyLayer::tx_parameter_s::fgprops.
  int get_tx_crc();

  /// \brief Return the value of \p fec0 in
  /// PhyLayer::tx_parameter_s::fgprops.
  int get_tx_fec0();

  /// \brief Return the value of \p fec1 in
  /// PhyLayer::tx_parameter_s::fgprops.
  int get_tx_fec1();

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::numSubcarriers.
  unsigned int get_tx_subcarriers();

  /// \brief Get current
  /// PhyLayer::tx_parameter_s::subcarrierAlloc.
  ///
  /// \p subcarrierAlloc should be a pointer to an array of size
  /// PhyLayer::tx_parameter_s::numSubcarriers.
  /// The array will then be filled with the current subcarrier allocation.
  void get_tx_subcarrier_alloc(char *subcarrierAlloc);

  /// \brief Return the value of
  /// PhyLayer::tx_parameter_s::cp_len.
  unsigned int get_tx_cp_len();

  /// \breif Return the value of
  /// PhyLayer::tx_parameter_s::taper_len.
  unsigned int get_tx_taper_len();

  void get_tx_control_info(unsigned char *_control_info);

  void start_tx();
  void start_tx_burst(unsigned int _num_tx_frames,
                      float _max_tx_time_ms);
  void stop_tx();
  void reset_tx();

  //=================================================================================
  // Receiver Methods
  //=================================================================================

  /// \brief Set the value of PhyLayer::rx_parameter_s::rx_freq.
  void set_rx_freq(double _rx_freq);

  void set_rx_freq(double _rx_freq, double _dsp_freq);

  /// \brief Set the value of PhyLayer::rx_parameter_s::rx_rate.
  void set_rx_rate(double _rx_rate);

  /// \brief Set the value of
  /// PhyLayer::rx_parameter_s::rx_gain_uhd.
  void set_rx_gain_uhd(double _rx_gain_uhd);

  void set_rx_antenna(char *_rx_antenna);

  /// \brief Set the value of
  /// PhyLayer::rx_parameter_s::numSubcarriers.
  void set_rx_subcarriers(unsigned int subcarriers);

  /// \brief Set PhyLayer::rx_parameter_s::subcarrierAlloc.
  void set_rx_subcarrier_alloc(char *_subcarrierAlloc);

  /// \brief Set the value of PhyLayer::rx_parameter_s::cp_len.
  void set_rx_cp_len(unsigned int cp_len);

  /// \brief Set the value of
  /// PhyLayer::rx_parameter_s::taper_len.
  void set_rx_taper_len(unsigned int taper_len);

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_state.
  int get_rx_state();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_worker_state.
  int get_rx_worker_state();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_freq.
  double get_rx_freq();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_freq.
  double get_rx_lo_freq();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_freq.
  double get_rx_dsp_freq();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_rate.
  double get_rx_rate();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::rx_gain_uhd.
  double get_rx_gain_uhd();

  char *get_rx_antenna();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::numSubcarriers.
  unsigned int get_rx_subcarriers();

  /// \brief Get current
  /// PhyLayer::rx_parameter_s::subcarrierAlloc.
  ///
  /// \p subcarrierAlloc should be a pointer to an array of size
  /// PhyLayer::rx_parameter_s::numSubcarriers.
  /// The array will then be filled with the current subcarrier allocation.
  void get_rx_subcarrier_alloc(char *subcarrierAlloc);

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::cp_len.
  unsigned int get_rx_cp_len();

  /// \brief Return the value of
  /// PhyLayer::rx_parameter_s::taper_len.
  unsigned int get_rx_taper_len();

  void get_rx_control_info(unsigned char *_control_info);

  void reset_rx();
  void start_rx();
  void stop_rx();
  void start_liquid_rx();
  void stop_liquid_rx();

  // functions/variables for tracking rx statistics
  void set_rx_stat_tracking(bool state, float sec);
  float get_rx_stat_tracking_period();
  struct rx_statistics get_rx_stats();
  void reset_rx_stats();

  //=================================================================================
  // USRP Objects
  //=================================================================================

  uhd::usrp::multi_usrp::sptr usrp_tx;
  uhd::tx_metadata_t metadata_tx;

  uhd::usrp::multi_usrp::sptr usrp_rx;
  uhd::rx_metadata_t metadata_rx;

  // Additional functions
  bool custom_uhd_set = false;
  uhd::device_addr_t dev_addr; //= new uhd::device_addr_t("192.168.10.2");

  void set_uhd(uhd::usrp::multi_usrp::sptr &usrp_tx,
               uhd::usrp::multi_usrp::sptr &usrp_rx,
               uhd::device_addr_t &dev_addr, char *tx_sub_addr, char *rx_sub_addr);

  bool custom_tun_set = false;
  char tun_name[IFNAMSIZ];
  int tx_queued_bytes;
  int tx_queue_len;
  void set_attributes();
  void set_ip(char *ip);

  //=================================================================================
  // Private Network Interface Objects
  //=================================================================================

  int tunfd; // virtual network interface
  // String for TUN interface name
  // String for commands for TUN interface
  char systemCMD[200];
  /// \brief Allows you to set the tx buffer length for the virtual network interface
  /// This could be useful in trading off between dropped packets and latency with a
  /// UDP connection
  void set_tx_queue_len(int queue_len);

  /// \brief Returns the number of bytes currently queued for transmission
  int get_tx_queued_bytes();

  /// \brief Decrements the count of bytes currently queued for transmission
  /// This function is only used as a work around since tun interfaces don't
  /// allow you to read the number of queued bytes.
  void dec_tx_queued_bytes(int n);

  /// \brief Increments the count of bytes currently queued for transmission
  /// This function is only used as a work around since tun interfaces don't
  /// allow you to read the number of queued bytes.
  void inc_tx_queued_bytes(int n);

  friend void uhd_msg_handler(uhd::msg::type_t type, const std::string &msg);
  static int uhd_msg;
  bool transmitting = false;
  
  void set_nco_offset(int consumer,float nco_offset);
  void setRxChannels(double rx_rate,int channels);
  char *createSubcarrierLayout(int num_subcarriers);
private:
  //=================================================================================
  // Private Receiver Objects
  //=================================================================================

  // receiver properties/objects
  struct rx_parameter_s rx_params;
  bool update_rx_flag;
  bool update_usrp_rx;
  bool recreate_fs;
  bool reset_fs;
  void update_rx_params();
  ofdmflexframesync fs; // frame synchronizer object
  ofdmflexframesync *fsyncs;
  unsigned int frame_num;
  unsigned int frame_uhd_overflows; // overflows that have occurred
  std::complex<float> *rx_buffer;
  size_t rx_buffer_len;

  // receiver threading objects
  pthread_t rx_process;            // receive thread
  pthread_mutex_t rx_mutex;        // receive mutex
  pthread_mutex_t rx_params_mutex; // change in params mutex
  pthread_cond_t rx_cond;          // receive condition
  int rx_state;                    // is receiver running?
  int rx_worker_state;
  bool rx_thread_running; // is receiver thread running?
  friend void *PHY_rx_worker(void *);

  // receiver callback
  friend int rxCallback(unsigned char *, int, unsigned char *, unsigned int,
                        int, framesyncstats_s, void *);

  //=================================================================================
  // Private Transmitter Objects
  //=================================================================================

  // transmitter properties/objects
  unsigned int tx_frame_counter;
  timer tx_timer;
  float max_tx_time_ms;
  tx_parameter_s tx_params;
  tx_parameter_s tx_params_updated;
  bool update_tx_flag;
  bool update_usrp_tx;
  bool recreate_fg;
  bool reset_fg;
  void update_tx_params();
  void transmit_frame(unsigned int frame_type,
                      unsigned char *_payload,
                      unsigned int _payload_len);
  ofdmflexframegen fg;           // frame generator object
  unsigned int fgbuffer_len;     // length of frame generator buffer
  std::complex<float> *fgbuffer; // frame generator output buffer [size:
                                 // numSubcarriers + cp_len x 1]
  unsigned char tx_header[8];    // header container (must have length 8)
  unsigned int frame_counter;
  unsigned int numDataSubcarriers;
  double tx_data_rate;
  int update_tx_data_rate;
  unsigned int num_tx_frames;

  // transmitter threading objects
  pthread_t tx_process;            // thread for transmission
  pthread_mutex_t tx_mutex;        //
  pthread_mutex_t tx_state_mutex;  // mutex to check for any change in tx
  pthread_mutex_t tx_params_mutex; // change in params
  pthread_cond_t tx_cond;
  bool tx_complete;
  bool tx_thread_running;
  int tx_worker_state;
  int tx_state;
  friend void *PHY_tx_worker(void *); // process called by thread

  pthread_mutex_t tx_rx_mutex;  

  Loop *test_loop;
  sem_t *test_phore;
 
  firinterp_crcf interp;
  firdecim_crcf  *decim;


  unsigned int resampler_factor;                   // samples/symbol
    
  unsigned int filter_delay;                   // filter delay
  float beta;                 // filter excess bandwidth


  unsigned int h_len;
  unsigned int num_symbols;


  unsigned int num_samples;

  float *h;
  float *g; 
  float nco_offset = 0.5e6;
  float tx_nco_offset = nco_offset;
  bool loop = false;
  bool random_data = false;
  float random_offset = 3*nco_offset;

  friend void *analysis(void *_arg);

  BufferQ<std::complex<float>> *recvQueue;
  pthread_t *analysisThreads;
  pthread_mutex_t *analysisMutex;
  int consumers;

  struct ThreadInfo{
    PhyLayer *PHY;
    int consumer;
    float nco_offset;
    bool new_info;
    ofdmflexframesync *fs_thread;
    bool packet_found;
  };

  ThreadInfo *threadInfo;

  bool route_resend = false;

  char tx_side = 0x00;

  int split_num = 0;
  void changeTxChannel();
  void resetResampler();
  void resetRxChannels();
  void adjustRxFreq(float freq_offset, int consumer);

  float phase_shift;


  struct SubcarrierInfo{
    float guard_nulls = float(1)/32; // fraction of nulls on either edge
    float dc_nulls = float(1)/32; // fraction of nulls at the center
    float pilots = float(1)/4; // fraction of pilots
  };

  SubcarrierInfo subcarrierInfo;

};